CREATE VIEW "public"."admin_apikey_stats" AS (select "apikey"."id", "apikey"."name", "apikey"."user_id", "user"."email", "user"."tier", "apikey"."enabled", "apikey"."rate_limit_enabled", "apikey"."request_count", "apikey"."remaining", "apikey"."last_request", "apikey"."created_at", "apikey"."expires_at", case 
        when "apikey"."expires_at" is not null and "apikey"."expires_at" < now() then 'expired'
        when not "apikey"."enabled" then 'disabled'
        else 'active'
      end as "status" from "apikey" inner join "user" on "user"."id" = "apikey"."user_id");--> statement-breakpoint
CREATE VIEW "public"."admin_daily_metrics" AS (select date("runs"."started_at") as "date", count(distinct "runs"."endpoint_id") as "active_endpoints", count("runs"."id") as "total_runs", count(case when "runs"."status" = 'success' then 1 end) as "successful_runs", count(case when "runs"."status" = 'failed' then 1 end) as "failed_runs", round(100.0 * count(case when "runs"."status" = 'success' then 1 end) / nullif(count("runs"."id"), 0), 2) as "success_rate_percent", avg("runs"."duration_ms") as "avg_duration_ms", count(distinct "ai_analysis_sessions"."id") as "ai_sessions", sum("ai_analysis_sessions"."token_usage") as "total_tokens" from "runs" left join "ai_analysis_sessions" on date("ai_analysis_sessions"."analyzed_at") = date("runs"."started_at") where "runs"."started_at" >= now() - interval '90 days' group by date("runs"."started_at") order by date desc);--> statement-breakpoint
CREATE VIEW "public"."admin_error_analysis" AS (select date("runs"."started_at") as "date", "runs"."status_code", left("runs"."error_message", 100) as "error_summary", count(*) as "error_count", count(distinct "runs"."endpoint_id") as "affected_endpoints", count(distinct "job_endpoints"."job_id") as "affected_jobs", count(distinct "jobs"."user_id") as "affected_users" from "runs" inner join "job_endpoints" on "job_endpoints"."id" = "runs"."endpoint_id" inner join "jobs" on "jobs"."id" = "job_endpoints"."job_id" inner join "user" on "user"."id" = "jobs"."user_id" where "runs"."status" in ('failed', 'timeout') and "runs"."started_at" >= now() - interval '7 days' group by date("runs"."started_at"), "runs"."status_code", left("runs"."error_message", 100) order by date desc, count(*) desc limit 100);--> statement-breakpoint
CREATE VIEW "public"."admin_run_source_stats" AS (select date("started_at") as "date", "source", count(*) as "run_count", count(case when "status" = 'success' then 1 end) as "successful_runs", count(case when "status" = 'failed' then 1 end) as "failed_runs" from "runs" where "runs"."started_at" >= now() - interval '30 days' and "runs"."source" is not null group by date("runs"."started_at"), "runs"."source" order by date desc, "runs"."source");--> statement-breakpoint
CREATE VIEW "public"."admin_subscription_overview" AS (select "tier", "subscription_status", count(*) as "user_count", count(case when "created_at" >= now() - interval '30 days' then 1 end) as "new_users_30d", count(case when "subscription_ends_at" is not null and "subscription_ends_at" < now() then 1 end) as "expired_subscriptions", count(case when "subscription_ends_at" is not null and "subscription_ends_at" > now() then 1 end) as "active_subscriptions" from "user" group by "user"."tier", "user"."subscription_status" order by "user"."tier", "user"."subscription_status");--> statement-breakpoint
CREATE VIEW "public"."admin_top_jobs" AS (select "jobs"."id", "jobs"."name", "jobs"."user_id", "user"."email", "user"."tier", "jobs"."status", count(distinct "job_endpoints"."id") as "endpoint_count", count("runs"."id") as "total_runs", count(case when "runs"."status" = 'success' then 1 end) as "successful_runs", count(case when "runs"."status" = 'failed' then 1 end) as "failed_runs", max("runs"."started_at") as "last_run_at", "jobs"."created_at" from "jobs" inner join "user" on "user"."id" = "jobs"."user_id" left join "job_endpoints" on "job_endpoints"."job_id" = "jobs"."id" left join "runs" on "runs"."endpoint_id" = "job_endpoints"."id" where "jobs"."archived_at" is null group by "jobs"."id", "jobs"."name", "jobs"."user_id", "user"."email", "user"."tier", "jobs"."status", "jobs"."created_at" order by count("runs"."id") desc limit 100);--> statement-breakpoint
CREATE VIEW "public"."admin_user_activity" AS (select "user"."id", "user"."email", "user"."tier", "user"."subscription_status", "user"."created_at", max("runs"."started_at") as "last_activity_date", extract(day from now() - max("runs"."started_at")) as "days_since_last_activity", count(distinct date("runs"."started_at")) as "total_active_days", case
        when max("runs"."started_at") >= now() - interval '7 days' then 'active'
        when max("runs"."started_at") >= now() - interval '30 days' then 'inactive'
        when max("runs"."started_at") is null then 'never_active'
        else 'churned'
      end as "activity_status" from "user" left join "jobs" on "jobs"."user_id" = "user"."id" left join "job_endpoints" on "job_endpoints"."job_id" = "jobs"."id" left join "runs" on "runs"."endpoint_id" = "job_endpoints"."id" group by "user"."id", "user"."email", "user"."tier", "user"."subscription_status", "user"."created_at" order by max("runs"."started_at") desc nulls last);--> statement-breakpoint
CREATE VIEW "public"."admin_user_ai_stats" AS (select "user"."id", "user"."email", "user"."tier", count("ai_analysis_sessions"."id") as "total_ai_sessions", sum("ai_analysis_sessions"."token_usage") as "total_tokens_used", avg("ai_analysis_sessions"."token_usage") as "avg_tokens_per_session", avg("ai_analysis_sessions"."duration_ms") as "avg_session_duration_ms", max("ai_analysis_sessions"."analyzed_at") as "last_ai_analysis_at", count(case when "ai_analysis_sessions"."analyzed_at" >= now() - interval '24 hours' then 1 end) as "ai_sessions_last_24h", count(case when "ai_analysis_sessions"."analyzed_at" >= now() - interval '7 days' then 1 end) as "ai_sessions_last_7d", count(case when "ai_analysis_sessions"."analyzed_at" >= now() - interval '30 days' then 1 end) as "ai_sessions_last_30d", sum(case when "ai_analysis_sessions"."analyzed_at" >= now() - interval '30 days' then "ai_analysis_sessions"."token_usage" else 0 end) as "tokens_last_30d" from "user" left join "jobs" on "jobs"."user_id" = "user"."id" left join "job_endpoints" on "job_endpoints"."job_id" = "jobs"."id" left join "ai_analysis_sessions" on "ai_analysis_sessions"."endpoint_id" = "job_endpoints"."id" group by "user"."id", "user"."email", "user"."tier");--> statement-breakpoint
CREATE VIEW "public"."admin_user_run_stats" AS (select "user"."id", "user"."email", "user"."tier", count("runs"."id") as "total_runs", count(case when "runs"."status" = 'success' then 1 end) as "successful_runs", count(case when "runs"."status" = 'failed' then 1 end) as "failed_runs", count(case when "runs"."status" = 'timeout' then 1 end) as "timeout_runs", round(100.0 * count(case when "runs"."status" = 'success' then 1 end) / nullif(count("runs"."id"), 0), 2) as "success_rate_percent", avg("runs"."duration_ms") as "avg_duration_ms", max("runs"."started_at") as "last_run_at", count(distinct date("runs"."started_at")) as "active_days", count(case when "runs"."started_at" >= now() - interval '24 hours' then 1 end) as "runs_last_24h", count(case when "runs"."started_at" >= now() - interval '7 days' then 1 end) as "runs_last_7d", count(case when "runs"."started_at" >= now() - interval '30 days' then 1 end) as "runs_last_30d" from "user" left join "jobs" on "jobs"."user_id" = "user"."id" left join "job_endpoints" on "job_endpoints"."job_id" = "jobs"."id" left join "runs" on "runs"."endpoint_id" = "job_endpoints"."id" group by "user"."id", "user"."email", "user"."tier");--> statement-breakpoint
CREATE VIEW "public"."admin_user_stats" AS (select "user"."id", "user"."email", "user"."name", "user"."tier", "user"."subscription_status", "user"."created_at", "user"."is_anonymous", "user"."subscription_ends_at", count(distinct "jobs"."id") as "total_jobs", count(distinct "job_endpoints"."id") as "total_endpoints", count(distinct case when "job_endpoints"."archived_at" is null then "job_endpoints"."id" end) as "active_endpoints", count(distinct case when "job_endpoints"."paused_until" is not null and "job_endpoints"."paused_until" > now() then "job_endpoints"."id" end) as "paused_endpoints" from "user" left join "jobs" on "jobs"."user_id" = "user"."id" and "jobs"."archived_at" is null left join "job_endpoints" on "job_endpoints"."job_id" = "jobs"."id" group by "user"."id", "user"."email", "user"."name", "user"."tier", "user"."subscription_status", "user"."created_at", "user"."is_anonymous", "user"."subscription_ends_at");