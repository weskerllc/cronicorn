{
  "category": "Uncategorized",
  "description": "TASK 2: Fix Refund Double-Charge Bug\nPriority: CRITICAL | Type: Bug fix | Estimated scope: 1 file + 1 test file\n\nContext:\nIn packages/services/src/subscriptions/manager.ts:117-207, the requestRefund() method has a critical ordering bug. The current flow:\n\nLine 153: Set refundStatus = \"requested\" in DB\nLine 165: Call paymentProvider.issueRefund() — this commits money in Stripe (irreversible)\nLine 177: Call paymentProvider.cancelSubscriptionNow() — this can fail\nLine 185: Update DB to tier: \"free\", refundStatus: \"issued\"\nIf step 3 fails, the catch block at line 200-205 rolls refundStatus back to \"eligible\". But the refund was already issued in Stripe at step 2. The user can then request another refund and get double their money back.\n\nWhat to implement:\n\nIn packages/services/src/subscriptions/manager.ts, reorder the requestRefund() method:\n\nStep 1: Set refundStatus = \"requested\" (keep as-is)\nStep 2: Cancel subscription first (cancelSubscriptionNow)\nStep 3: Issue refund second (issueRefund)\nStep 4: Update DB to final state\nIn the catch block: if the refund was already issued (track with a local boolean), set refundStatus = \"issued\" instead of \"eligible\". If only cancellation succeeded, set a new status \"cancel_failed\" or keep as \"requested\" so it can be retried but not re-initiated.\nIn the catch block, differentiate between:\n\nCancel failed (before refund): safe to retry, keep refundStatus = \"requested\"\nRefund failed (after cancel): set refundStatus = \"cancel_completed_refund_failed\" or similar — log and alert, needs manual intervention\nBoth succeeded but DB update failed: set refundStatus = \"issued\" as a fallback\nAdd tests in packages/services/src/subscriptions/__tests__/manager.test.ts:\n\nTest: cancelSubscriptionNow throws → refund is NOT issued, status stays \"requested\", no money leaves\nTest: issueRefund throws after cancel succeeds → status reflects partial completion\nTest: successful full flow (already exists, verify it still passes)\nKey files to read first:\n\npackages/services/src/subscriptions/manager.ts (full file, especially lines 117-207)\npackages/services/src/subscriptions/__tests__/manager.test.ts (understand mock patterns, lines 24-50 for mock factories, lines 452-516 for existing refund tests)\nConventions:\n\nFollow conventional commits: fix(subscriptions): prevent double-refund on partial failure\nNo any types — the existing test file uses typed mocks\nRun pnpm test after changes",
  "title": "Fix subscription refund double-charge bug",
  "images": [],
  "imagePaths": [],
  "textFilePaths": [],
  "skipTests": true,
  "model": "opus",
  "thinkingLevel": "none",
  "reasoningEffort": "none",
  "priority": 2,
  "planningMode": "spec",
  "requirePlanApproval": false,
  "dependencies": [],
  "workMode": "current",
  "titleGenerating": false,
  "status": "backlog",
  "id": "feature-0770422413839-1p7h8dsip",
  "descriptionHistory": [
    {
      "description": "TASK 2: Fix Refund Double-Charge Bug\nPriority: CRITICAL | Type: Bug fix | Estimated scope: 1 file + 1 test file\n\nContext:\nIn packages/services/src/subscriptions/manager.ts:117-207, the requestRefund() method has a critical ordering bug. The current flow:\n\nLine 153: Set refundStatus = \"requested\" in DB\nLine 165: Call paymentProvider.issueRefund() — this commits money in Stripe (irreversible)\nLine 177: Call paymentProvider.cancelSubscriptionNow() — this can fail\nLine 185: Update DB to tier: \"free\", refundStatus: \"issued\"\nIf step 3 fails, the catch block at line 200-205 rolls refundStatus back to \"eligible\". But the refund was already issued in Stripe at step 2. The user can then request another refund and get double their money back.\n\nWhat to implement:\n\nIn packages/services/src/subscriptions/manager.ts, reorder the requestRefund() method:\n\nStep 1: Set refundStatus = \"requested\" (keep as-is)\nStep 2: Cancel subscription first (cancelSubscriptionNow)\nStep 3: Issue refund second (issueRefund)\nStep 4: Update DB to final state\nIn the catch block: if the refund was already issued (track with a local boolean), set refundStatus = \"issued\" instead of \"eligible\". If only cancellation succeeded, set a new status \"cancel_failed\" or keep as \"requested\" so it can be retried but not re-initiated.\nIn the catch block, differentiate between:\n\nCancel failed (before refund): safe to retry, keep refundStatus = \"requested\"\nRefund failed (after cancel): set refundStatus = \"cancel_completed_refund_failed\" or similar — log and alert, needs manual intervention\nBoth succeeded but DB update failed: set refundStatus = \"issued\" as a fallback\nAdd tests in packages/services/src/subscriptions/__tests__/manager.test.ts:\n\nTest: cancelSubscriptionNow throws → refund is NOT issued, status stays \"requested\", no money leaves\nTest: issueRefund throws after cancel succeeds → status reflects partial completion\nTest: successful full flow (already exists, verify it still passes)\nKey files to read first:\n\npackages/services/src/subscriptions/manager.ts (full file, especially lines 117-207)\npackages/services/src/subscriptions/__tests__/manager.test.ts (understand mock patterns, lines 24-50 for mock factories, lines 452-516 for existing refund tests)\nConventions:\n\nFollow conventional commits: fix(subscriptions): prevent double-refund on partial failure\nNo any types — the existing test file uses typed mocks\nRun pnpm test after changes",
      "timestamp": "2026-02-07T00:00:02.098Z",
      "source": "initial"
    }
  ]
}
