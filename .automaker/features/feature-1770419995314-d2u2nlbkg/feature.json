{
  "category": "Uncategorized",
  "description": "TASK 7: Add Cross-User Authorization Tests\nPriority: HIGH | Type: Test coverage | Estimated scope: 1 test file\n\nContext:\nEvery test in apps/api/src/routes/jobs/__tests__/jobs.api.test.ts uses a single user (mockUserId = \"test-user-1\"). There are zero tests verifying that one user cannot access another user's data. The authorization logic exists in the service layer (packages/services/src/jobs/manager.ts — getJob() at line 196, getEndpoint() at line 418, etc.) but it's untested at the API boundary.\n\nWhat to implement:\n\nAdd a new describe block in apps/api/src/routes/jobs/__tests__/jobs.api.test.ts (or a new file jobs.authorization.test.ts in the same directory) titled \"Cross-user authorization\".\n\nThe test pattern (based on existing patterns in the file):\n\n// Setup: create two users\nconst userA = \"user-a\";\nconst userB = \"user-b\";\nawait createTestUser(tx, { id: userA });\nawait createTestUser(tx, { id: userB });\n\n// Create app instances with different auth contexts\nconst mockAuthA = createMockAuth(createMockSession(userA));\nconst mockAuthB = createMockAuth(createMockSession(userB));\nconst { app: appA } = await createApp(tx, testConfig, mockAuthA, { useTransactions: false });\nconst { app: appB } = await createApp(tx, testConfig, mockAuthB, { useTransactions: false });\n\nWrite these specific tests:\n\nGET /api/jobs/:id — User B gets 404 for User A's job (not 403, to avoid leaking existence)\nPATCH /api/jobs/:id — User B cannot update User A's job\nDELETE /api/jobs/:id — User B cannot delete User A's job\nPOST /api/jobs/:id/archive — User B cannot archive User A's job\nGET /api/jobs/:id/endpoints — User B cannot list User A's endpoints\nPOST /api/jobs/:id/endpoints — User B cannot add endpoints to User A's job\nPATCH /api/endpoints/:id — User B cannot update User A's endpoint\nDELETE /api/endpoints/:id — User B cannot delete User A's endpoint\nGET /api/runs with endpointId filter — User B cannot see User A's runs\nGET /api/runs/:id — User B cannot see details of User A's run\nEach test should verify:\n\nHTTP status is 404 (not 500 or 200)\nNo data is leaked in the response body\nKey files to read first:\n\napps/api/src/routes/jobs/__tests__/jobs.api.test.ts — understand the test fixture pattern (lines 26-63 especially)\napps/api/src/auth/middleware.ts — understand createMockAuth and createMockSession helpers\npackages/services/src/jobs/manager.ts — see authorization checks\nConventions:\n\nUse the existing test.extend() and tx fixture pattern for transaction-per-test\nCommit as test(api): add cross-user authorization tests\nRun pnpm test to verify all pass",
  "title": "Add cross-user authorization API tests",
  "images": [],
  "imagePaths": [],
  "textFilePaths": [],
  "skipTests": true,
  "model": "opus",
  "thinkingLevel": "none",
  "reasoningEffort": "none",
  "priority": 2,
  "planningMode": "spec",
  "requirePlanApproval": false,
  "dependencies": [],
  "workMode": "current",
  "titleGenerating": false,
  "status": "backlog",
  "id": "feature-1770419995314-d2u2nlbkg",
  "descriptionHistory": [
    {
      "description": "TASK 7: Add Cross-User Authorization Tests\nPriority: HIGH | Type: Test coverage | Estimated scope: 1 test file\n\nContext:\nEvery test in apps/api/src/routes/jobs/__tests__/jobs.api.test.ts uses a single user (mockUserId = \"test-user-1\"). There are zero tests verifying that one user cannot access another user's data. The authorization logic exists in the service layer (packages/services/src/jobs/manager.ts — getJob() at line 196, getEndpoint() at line 418, etc.) but it's untested at the API boundary.\n\nWhat to implement:\n\nAdd a new describe block in apps/api/src/routes/jobs/__tests__/jobs.api.test.ts (or a new file jobs.authorization.test.ts in the same directory) titled \"Cross-user authorization\".\n\nThe test pattern (based on existing patterns in the file):\n\n// Setup: create two users\nconst userA = \"user-a\";\nconst userB = \"user-b\";\nawait createTestUser(tx, { id: userA });\nawait createTestUser(tx, { id: userB });\n\n// Create app instances with different auth contexts\nconst mockAuthA = createMockAuth(createMockSession(userA));\nconst mockAuthB = createMockAuth(createMockSession(userB));\nconst { app: appA } = await createApp(tx, testConfig, mockAuthA, { useTransactions: false });\nconst { app: appB } = await createApp(tx, testConfig, mockAuthB, { useTransactions: false });\n\nWrite these specific tests:\n\nGET /api/jobs/:id — User B gets 404 for User A's job (not 403, to avoid leaking existence)\nPATCH /api/jobs/:id — User B cannot update User A's job\nDELETE /api/jobs/:id — User B cannot delete User A's job\nPOST /api/jobs/:id/archive — User B cannot archive User A's job\nGET /api/jobs/:id/endpoints — User B cannot list User A's endpoints\nPOST /api/jobs/:id/endpoints — User B cannot add endpoints to User A's job\nPATCH /api/endpoints/:id — User B cannot update User A's endpoint\nDELETE /api/endpoints/:id — User B cannot delete User A's endpoint\nGET /api/runs with endpointId filter — User B cannot see User A's runs\nGET /api/runs/:id — User B cannot see details of User A's run\nEach test should verify:\n\nHTTP status is 404 (not 500 or 200)\nNo data is leaked in the response body\nKey files to read first:\n\napps/api/src/routes/jobs/__tests__/jobs.api.test.ts — understand the test fixture pattern (lines 26-63 especially)\napps/api/src/auth/middleware.ts — understand createMockAuth and createMockSession helpers\npackages/services/src/jobs/manager.ts — see authorization checks\nConventions:\n\nUse the existing test.extend() and tx fixture pattern for transaction-per-test\nCommit as test(api): add cross-user authorization tests\nRun pnpm test to verify all pass",
      "timestamp": "2026-02-06T23:19:55.663Z",
      "source": "initial"
    }
  ]
}
